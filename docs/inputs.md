# Input Modes

POET accepts multiple input formats to generate test plans. Choose the mode that fits your workflow.

---

## Overview

| Input Mode | Command | Best For |
|------------|---------|----------|
| [Jira](#jira-text-file-api) | `poet build --jira-text/--jira-file/--jira-key` | Feature-driven testing |
| [Markdown Spec](#markdown-feature-spec) | `poet build --jira-file spec.md` | Version-controlled specs |
| [OpenAPI/Swagger](#openapiswagger) | `poet build --openapi api.yaml` | API contract testing |
| [System Profile](#system-profile) | `poet build --profile .poet/profile.json` | Environment-aware testing |
| [Existing Tests](#existing-tests-maintainer-only) | `poet learn from-tests ./tests/` | Knowledge extraction |
| [Direct Selection](#direct-obligation-selection) | `poet build --obligations cache.* --packs edge-http-cache-correctness` | Manual control |

---

## Jira (Text, File, API)

See **[docs/jira.md](jira.md)** for complete Jira integration guide.

**Quick examples:**

```bash
# Inline text
poet build --jira-text "Add cache bypass for auth requests..."

# From file
poet build --jira-file ticket.md --jira-key EDGE-123

# From Jira API
poet build --jira-key EDGE-123 --jira-url https://company.atlassian.net --jira-token-env JIRA_TOKEN
```

---

## Markdown Feature Spec

Use a structured markdown file as input. Ideal for version-controlled specifications.

### When to Use

- Feature specs reviewed in PRs before implementation
- Air-gapped environments without Jira access
- Batch processing multiple features
- Reproducible test plan generation

### Command Examples

```bash
# Basic usage
poet build --jira-file feature-spec.md

# With metadata
poet build --jira-file feature-spec.md \
           --title "Cache Bypass Feature" \
           --jira-key EDGE-123 \
           --output ./test-plans/edge-123
```

### Expected File Structure

```markdown
# Feature Title

## Summary
One-line description of the feature.

## Description
Technical details about what's being implemented.
Include affected components, protocols, and constraints.

## Acceptance Criteria
- [ ] First testable criterion
- [ ] Second testable criterion
- [ ] Third testable criterion

## Environment (optional)
- Proxy: NGINX 1.25
- Cache: Redis 7.0
- Load balancer: HAProxy 2.8

## Out of Scope (optional)
- Things explicitly NOT covered by this feature
```

### Generated Artifacts

| Artifact | Description |
|----------|-------------|
| `TESTPLAN.md` | Test plan with failure modes and test cases |
| `tests/` | Pytest starter files |
| `observability/` | Monitoring recipes |
| `snippets/` | Code helpers |

### Limitations

- POET extracts keywords from text; vague descriptions produce generic plans
- No automatic validation of markdown structure
- Acceptance criteria should be testable assertions, not vague goals

---

## OpenAPI/Swagger

Generate test plans from API specifications. Focuses on contract testing and edge cases.

### When to Use

- API-first development
- Contract testing between services
- Generating tests for all endpoints systematically
- Validating request/response schemas

### Command Examples

```bash
# From OpenAPI 3.x file
poet build --openapi api.yaml --output ./api-tests

# With specific paths
poet build --openapi api.yaml --paths "/users/*,/orders/*"

# Combined with feature spec
poet build --openapi api.yaml --jira-file feature.md
```

### Expected File Structure

Standard OpenAPI 3.x or Swagger 2.0 format:

```yaml
openapi: 3.0.0
info:
  title: Edge API
  version: 1.0.0
paths:
  /api/v1/users:
    get:
      summary: List users
      responses:
        '200':
          description: Success
        '429':
          description: Rate limited
```

### Generated Artifacts

| Artifact | Description |
|----------|-------------|
| `TESTPLAN.md` | Test cases per endpoint |
| `tests/test_api_*.py` | Contract tests for each path |
| `observability/api-metrics.md` | API-specific monitoring |

### Limitations

- ðŸ§ª **Status: Experimental** â€” Basic support available
- Will focus on HTTP contract testing, not business logic
- Requires well-documented OpenAPI spec with response schemas

---

## System Profile

Use the system profile generated by `poet init` to create environment-aware test plans.

### When to Use

- Tests need to match actual infrastructure
- Different test plans for staging vs production
- Capability-aware test generation (e.g., skip DTrace tests if unavailable)
- CI/CD pipelines with environment detection

### Command Examples

```bash
# Generate profile first
poet init

# Use profile for context
poet build --jira-file feature.md --profile .poet/profile.json

# Use specific profile
poet build --jira-file feature.md --profile profiles/production.json
```

### Profile Structure

Generated by `poet init`:

```json
{
  "created_at": "2026-02-05T08:00:00Z",
  "system": {
    "os": "linux",
    "arch": "x86_64",
    "kernel": "5.15.0"
  },
  "capabilities": {
    "dtrace": false,
    "bpftrace": true,
    "tcpdump": true,
    "docker": true
  },
  "proxy": {
    "type": "nginx",
    "version": "1.25.3",
    "config_path": "/etc/nginx/nginx.conf"
  },
  "environment": "staging"
}
```

### Generated Artifacts

| Artifact | Description |
|----------|-------------|
| `TESTPLAN.md` | Environment-aware test plan |
| `tests/` | Tests using available capabilities |
| `observability/` | Recipes for detected tools |

### Limitations

- Profile must be regenerated when infrastructure changes
- Manual profile editing supported but not validated
- Some capabilities require root/sudo to detect

---

## Existing Tests (Maintainer-Only)

Extract patterns from legacy test suites. **This is a maintainer workflow**, not for regular users.

### When to Use

- Onboarding legacy test suites into POET
- Extracting institutional knowledge from existing tests
- Building knowledge base for new teams
- Migrating from custom test frameworks

### Command Examples

```bash
# Learn from test directory
poet learn from-tests /path/to/legacy/tests/

# Learn from specific files
poet learn from-tests ./tests/test_cache.py ./tests/test_routing.py

# Show learned patterns
poet learn show
poet learn show --section fixtures
poet learn show --section assertions

# Merge with existing knowledge
poet learn from-tests ./more-tests/ --merge
```

### What POET Extracts

| Pattern Type | Examples |
|--------------|----------|
| **Fixtures** | Server mocks, client setup, config loaders |
| **Assertions** | Status codes, headers, timing, cache status |
| **Signals** | Endpoints, ports, hostnames |
| **Observability** | tcpdump, dtrace, log parsing |
| **Fault injection** | Timeouts, connection drops, error injection |

### Generated Artifacts

| Artifact | Location | Description |
|----------|----------|-------------|
| Learned patterns | `.poet/learned/*.json` | Raw extracted knowledge (git-ignored) |
| Risk rules | Embedded in patterns | Pack recommendations |

### Limitations

- Static analysis only â€” tests are NOT executed
- Python/pytest tests only (currently)
- Requires well-structured tests with clear assertions
- Some patterns need manual curation before committing

### Workflow

```bash
# 1. Extract patterns
poet learn from-tests /path/to/tests/

# 2. Review
poet learn show
cat .poet/learned/*.json

# 3. Sanitize (remove proprietary references)
# Edit JSON files manually or use sanitization script

# 4. Curate and commit
cp .poet/learned/extraction_*.json knowledge/curated/
git add knowledge/curated/
git commit -m "Add curated patterns from project X"
```

---

## Direct Obligation Selection

Manually select obligations and packs without feature description analysis.

### When to Use

- You know exactly which obligations to test
- Generating tests for specific failure modes
- Compliance testing (must cover specific obligations)
- Exploring available packs

### Command Examples

```bash
# Select by obligation pattern
poet build --obligations "cache.*" --output ./cache-tests

# Select specific obligations
poet build --obligations "cache.key.stability,cache.vary.honored"

# Select by pack
poet build --packs edge-http-cache-correctness --output ./cache-tests

# Combine pack and obligations
poet build --packs fault-injection-io --obligations "resilience.*"

# List available obligations first
poet obligations list
poet obligations list --domain cache
```

### Generated Artifacts

| Artifact | Description |
|----------|-------------|
| `TESTPLAN.md` | Test plan for selected obligations |
| `tests/` | Tests covering selected failure modes |
| `observability/` | Recipes from selected packs |

### Limitations

- No automatic pack selection â€” you must know what you need
- No feature context â€” tests are generic for the obligation
- May miss related obligations that would be auto-selected

---

## Combining Input Modes

Input modes can be combined for richer context:

```bash
# Feature spec + system profile
poet build --jira-file feature.md --profile .poet/profile.json

# Feature spec + explicit obligations
poet build --jira-file feature.md --obligations "resilience.*"

# OpenAPI + feature context (when supported)
poet build --openapi api.yaml --jira-file feature.md
```

---

## Quick Reference

```bash
# Jira (see docs/jira.md for details)
poet build --jira-text "..."
poet build --jira-file ticket.md
# poet build --jira-key PROJ-123 --jira-url ... (planned)

# Markdown spec
poet build --jira-file feature-spec.md

# OpenAPI (experimental)
poet build --openapi api.yaml

# System profile
poet init
poet build --jira-file feature.md --profile .poet/profile.json

# Existing tests (maintainers)
poet learn from-tests ./tests/

# Direct selection
poet build --obligations "cache.*"
poet build --packs edge-http-cache-correctness
```

---

## See Also

- [docs/jira.md](jira.md) â€” Jira integration details
- [docs/outputs.md](outputs.md) â€” Output artifact descriptions
- [README.md](../README.md) â€” Project overview
