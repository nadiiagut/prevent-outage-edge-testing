# Observability Runbook: Cache Invalidation Feature

**Generated by**: POET v1.0  
**Feature**: Cache invalidation with Vary header support  
**Related Obligations**: cache.vary.honored, observability.access.logged, observability.metrics.exposed

---

## Purpose

This runbook describes what signals to collect and monitor when testing cache invalidation behavior. Evidence collected here supports release gate decisions.

## Required Signals

### 1. Access Logs

**What to capture**:
- Cache status per request (HIT/MISS/BYPASS/EXPIRED)
- Vary header value from origin
- Request headers that affect caching (Accept-Encoding, Cookie, etc.)

**Log fields to verify**:
```
timestamp | client_ip | method | path | status | cache_status | vary_header | upstream_time
```

**Example log entry**:
```
2026-02-04T10:15:32Z | 10.0.0.1 | GET | /resource | 200 | HIT | Accept-Encoding | 0.001
2026-02-04T10:15:33Z | 10.0.0.1 | GET | /resource | 200 | MISS | Accept-Encoding | 0.045
```

### 2. Metrics

**Counters to monitor**:
| Metric | Description |
|--------|-------------|
| `cache_hits_total` | Total cache hits |
| `cache_misses_total` | Total cache misses |
| `purge_requests_total` | Total purge API calls |
| `purge_keys_invalidated` | Keys invalidated per purge |

**Example Prometheus queries**:
```promql
# Cache hit ratio
sum(rate(cache_hits_total[5m])) / sum(rate(cache_hits_total[5m]) + rate(cache_misses_total[5m]))

# Purge rate
rate(purge_requests_total[1m])
```

### 3. Request/Response Captures

For each test case, capture:

```yaml
evidence:
  request:
    method: GET
    path: /resource
    headers:
      Accept-Encoding: gzip
      Host: example.com
  response:
    status: 200
    headers:
      X-Cache: HIT
      Content-Encoding: gzip
      Vary: Accept-Encoding
    body_hash: sha256:abc123...
  timing:
    total_ms: 12
    upstream_ms: 0
```

## Collection Methods

### Method A: Access Log Parsing

```bash
# Extract cache status from NGINX logs
tail -f /var/log/nginx/access.log | grep -E "(HIT|MISS|BYPASS)"

# Count by status
awk '{print $NF}' /var/log/nginx/access.log | sort | uniq -c
```

### Method B: Metrics Endpoint

```bash
# Scrape metrics
curl -s http://localhost:8080/metrics | grep cache_

# Expected output:
# cache_hits_total 1234
# cache_misses_total 567
```

### Method C: Packet Capture (when needed)

For debugging cache key issues:

```bash
# Capture HTTP traffic
tcpdump -i any -A -s0 'port 80 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420)'
```

## Evidence Storage

Store evidence in `.poet/evidence/<run-id>/`:

```
.poet/evidence/
└── 2026-02-04-cache-test/
    ├── access.log
    ├── metrics_before.txt
    ├── metrics_after.txt
    ├── tc001_request.json
    ├── tc001_response.json
    └── summary.json
```

## Alerts to Watch

During testing, monitor for:

| Alert | Threshold | Action |
|-------|-----------|--------|
| Cache hit ratio drop | < 50% | Verify cache config |
| Purge latency spike | > 1s | Check purge queue |
| 5xx errors | > 0.1% | Stop test, investigate |

## Post-Test Verification

After test run:

1. [ ] Access logs contain all test requests
2. [ ] Metrics show expected cache behavior
3. [ ] No unexpected errors in error log
4. [ ] Evidence files saved and checksummed
