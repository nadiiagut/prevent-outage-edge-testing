# Test Plan: Cache Invalidation with Vary Header Support

**Generated by**: POET v1.0  
**Date**: 2026-02-04  
**Source**: Jira ticket EDGE-1234  
**Feature**: Implement CDN cache invalidation with purge API and Vary header support

---

## Summary

This test plan covers cache invalidation behavior when Vary headers are present. The feature introduces a purge API that must correctly invalidate all variants of a cached resource.

## Matched Obligations

| Obligation | Risk | Status |
|------------|------|--------|
| cache.key.stability | high | requires verification |
| cache.vary.honored | high | requires verification |
| protocol.http.status | high | requires verification |
| observability.access.logged | high | requires verification |

## Test Cases

### TC-001: Vary Accept-Encoding produces separate cache entries

**Obligation**: cache.vary.honored

**Setup**:
1. Configure origin to return `Vary: Accept-Encoding`
2. Clear cache

**Steps**:
1. Request resource with `Accept-Encoding: gzip`
2. Verify response is cached (X-Cache: HIT on second request)
3. Request same resource with `Accept-Encoding: identity`
4. Verify cache miss (different variant)
5. Verify response is correct encoding

**Pass Criteria**:
- [ ] Gzip request returns gzip-encoded body
- [ ] Identity request returns uncompressed body
- [ ] Both variants cached independently

**Evidence to Capture**:
- Request/response headers for both variants
- X-Cache header values
- Content-Encoding header values

---

### TC-002: Purge API invalidates all variants

**Obligation**: cache.key.stability

**Setup**:
1. Populate cache with multiple variants of `/resource`
2. Verify all variants are cached (X-Cache: HIT)

**Steps**:
1. Send PURGE request to `/resource`
2. Verify 200 response from purge API
3. Request each variant again
4. Verify all return X-Cache: MISS

**Pass Criteria**:
- [ ] Purge returns 200 OK
- [ ] All variants invalidated (not just one)
- [ ] Subsequent requests go to origin

**Evidence to Capture**:
- Purge request/response
- Cache status before and after purge
- Origin request count

---

### TC-003: Cache key stability across query param order

**Obligation**: cache.key.stability

**Setup**:
1. Clear cache

**Steps**:
1. Request `/resource?a=1&b=2`
2. Verify cache miss, response cached
3. Request `/resource?b=2&a=1`
4. Verify cache hit (same key)

**Pass Criteria**:
- [ ] Query param order does not affect cache key
- [ ] Second request is cache hit

**Evidence to Capture**:
- X-Cache headers
- Cache key (if exposed via debug header)

---

### TC-004: Purge non-existent resource returns appropriate status

**Obligation**: protocol.http.status

**Steps**:
1. Send PURGE request to `/nonexistent-resource`
2. Verify response status

**Pass Criteria**:
- [ ] Returns 404 (not found) or 200 (no-op success)
- [ ] Does not return 500

**Evidence to Capture**:
- Response status code
- Response body

---

## Observability Checklist

- [ ] Access logs contain cache status field
- [ ] Purge requests are logged with resource path
- [ ] Cache hit/miss ratio available in metrics

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Vary header ignored | Medium | High | TC-001 verifies variant isolation |
| Partial purge (one variant only) | Medium | High | TC-002 verifies all variants purged |
| Cache key collision | Low | High | TC-003 verifies key stability |

## Notes

- This test plan was generated from obligation definitions
- Tests must be bound to your specific cache configuration
- Evidence files should be stored in `.poet/evidence/<run-id>/`
